const commandParser = require('../parsers/commandParser');
const walletHandler = require('./walletHandler');
const transactionHandler = require('./transactionHandler');
const contactHandler = require('./contactHandler');
const claimsService = require('../services/claims');
const nebulaService = require('../services/nebula');
const { logger, logUserAction } = require('../utils/logger');
const { users } = require('../services/database');
const config = require('../config');
const nebulaChat = require('../services/nebulaChat');
const whatsappService = require('../services/whatsapp');
const testnetMigration = require('../services/testnetMigration');
const errorHandler = require('../utils/errorHandler');
const errorRecovery = require('../utils/errorRecovery');
const { deposit, checkBalances, getZAPBalance } = require('../../Web3/contracts/connections');
const { swapUSDCtoWETH, getSwapQuote } = require('../../Web3/swapService');
const { getTokenBalances } = require('../../Web3/balanceService');

// Inject sendMessage function and shared state into handlers
const injectSendMessage = (sendMessageFunc, pendingTransactions) => {
  walletHandler.sendMessage = sendMessageFunc;
  transactionHandler.sendMessage = sendMessageFunc;
  transactionHandler.pendingTransactions = pendingTransactions; // Share pending transactions
  contactHandler.sendMessage = sendMessageFunc;
};

class CommandHandler {
  constructor(whatsapp) {
    this.whatsapp = whatsapp;
    this.userStates = new Map(); // Track user conversation states
    this.pendingTransactions = new Map(); // Track pending transaction confirmations
    this.seenGroupNotice = new Set();
  }
  
  // Initialize command handler and set up message listeners
  initialize() {
    // Inject sendMessage function and shared state into handlers
    injectSendMessage(this.sendMessage.bind(this), this.pendingTransactions);
    
    this.whatsapp.on('message', async (messageData) => {
      await this.handleMessage(messageData);
    });
    // New: handle shared contacts
    this.whatsapp.on('contact_shared', async (payload) => {
      await this.handleSharedContact(payload);
    });
    
    logger.info('‚úÖ Command handler initialized');
  }
  
  // Main message handling function
  async handleMessage(messageData) {
    try {
      const { from, text, timestamp } = messageData;
      const phone = this.extractPhoneNumber(from);
      
      logUserAction(phone, 'message_received', { 
        text: text.substring(0, 100),
        isReaction: messageData.isReaction || false 
      });

      // Chat-only mode removed; proceed with command parsing
      
      // Check if user has a pending transaction confirmation
      if (this.pendingTransactions.has(phone)) {
        logger.info(`Processing transaction confirmation for ${phone}: "${text}"`);
        await this.handleTransactionConfirmation(from, phone, text);
        return;
      }
      
      // Check if user is in a specific state (wallet creation, import, etc.)
      if (this.userStates.has(phone)) {
        await this.handleStatefulMessage(from, phone, text);
        return;
      }

      // Parse the command/intent
      const parsed = commandParser.parseInput(text);
      
      // Debug logging to see what's happening
      logger.info(`Command parsed: ${text} -> Intent: ${parsed.intent}`);
      
      if (parsed.intent === 'UNKNOWN') {
        // Check if this is a first-time user (no wallet, no state) ONLY for unknown commands
        const existingUser = await users.findUserByPhone(phone);
        if (!existingUser && !text.toLowerCase().includes('help')) {
          await this.sendMessage(from, this.getWelcomeMessage());
          return;
        }
        // For existing users with unknown commands, show help
        await this.sendMessage(from, this.getUnknownCommandResponse());
        return;
      }
      
      if (parsed.intent === 'ERROR') {
        await this.sendMessage(from, 'Sorry, I couldn‚Äôt process that request. Please try again.');
        return;
      }
      
      // Admin-only commands (STATUS and RESET)
      if (this.isAdminCommand(text)) {
        await this.handleAdminCommand(from, phone, text);
        return;
      }
      
      // Route to appropriate handler
      await this.routeCommand(from, phone, parsed);
      
    } catch (error) {
      const errorInfo = errorHandler.handleError(error, {
        action: 'handle_message',
        phone: this.extractPhoneNumber(messageData.from),
        message: messageData.text
      });
      
      // Create enhanced error message with recovery options
      const enhancedMessage = errorRecovery.createEnhancedErrorMessage(errorInfo);
      
      await this.sendMessage(messageData.from, enhancedMessage);
      
      // If it's a high severity error, log additional details
      if (errorInfo.severity === 'high') {
        logger.error('High severity error in message handling:', {
          phone: this.extractPhoneNumber(messageData.from),
          error: error.message,
          stack: error.stack
        });
      }
    }
  }

  // Handle shared contact payload
  async handleSharedContact(payload) {
    const { from, phones } = payload;
    const senderPhone = this.extractPhoneNumber(from);
    try {
      const { users } = require('../services/database');
      // Prefer the first resolvable phone
      for (const p of phones) {
        const normalized = p.replace(/^\+/, '');
        const contactUser = await users.findUserByPhone(normalized);
        if (contactUser) {
          // Get display name - use phone number if no other info available
          const displayName = normalized; // Could be enhanced to get actual name from contacts
          
          await this.sendMessage(from, `‚úÖ Contact is registered on ZAPPO testnet.\n\nüè¶ *Testnet Address:* \`${contactUser.wallet_address}\`\n\nüß™ How much testnet ETH do you want to send?`);
          // Prime a state to expect amount then confirmation
          this.userStates.set(senderPhone, {
            state: 'AWAITING_AMOUNT_FOR_CONTACT',
            targetAddress: contactUser.wallet_address,
            contactPhone: normalized,
            contactName: displayName,
            timestamp: Date.now()
          });
          return;
        } else {
          // Not registered ‚Üí offer claim-link escrow flow
          await this.sendMessage(from, `üë§ This contact isn't registered on ZAPPO testnet yet.\n\nThey'll have up to 3 days to claim a testnet transfer you initiate; if they don't, it's automatically refunded to you.\n\nüß™ *Note:* This uses testnet ETH - no real money involved!\n\nHow much testnet ETH would you like to send?`);
          this.userStates.set(senderPhone, {
            state: 'AWAITING_AMOUNT_FOR_UNREGISTERED',
            recipientPhone: normalized,
            timestamp: Date.now()
          });
          return;
        }
      }
      await this.sendMessage(from, '‚ÑπÔ∏è Couldn‚Äôt read a phone number from that contact. Please share again or paste a 0x address.');
    } catch (e) {
      logger.error('Error handling shared contact:', e);
      await this.sendMessage(from, '‚ùå Could not process the shared contact. Please try again.');
    }
  }
  
  // Route commands to appropriate handlers
  async routeCommand(from, phone, parsed) {
    const { intent, parameters } = parsed;
    
    try {
      switch (intent) {
        case 'HELP':
          await this.sendMessage(from, commandParser.getHelpText());
          break;
          
        case 'GREETING':
          await this.handleGreeting(from, phone);
          break;
          
        case 'CREATE_WALLET':
          await this.handleCreateWallet(from, phone);
          break;
          
        case 'IMPORT_WALLET':
          await this.handleImportWallet(from, phone);
          break;
          
        case 'BACKUP_WALLET':
          await walletHandler.handleBackup(from, phone);
          break;
          
        case 'GET_BALANCE':
          await transactionHandler.handleGetBalance(from, phone);
          break;
          
        case 'GET_HISTORY':
          await transactionHandler.handleGetHistory(from, phone);
          break;
          
        case 'SEND_ARB':
        case 'SEND_COMMAND':
        case 'NATURAL_SEND':
          await this.handleSendTransaction(from, phone, parameters);
          break;
          
        case 'SEND_ARB_START':
          await this.handleSendTransaction(from, phone, { intent: 'SEND_ARB_START' });
          break;

        case 'SEND_FUNDS':
          await this.handleSendFundsMenu(from, phone);
          break;

        case 'EXPLORE_DEFI':
          await this.handleExploreDeFiMenu(from, phone);
          break;

        case 'SEND_TO_CONTACT':
          await this.handleSendToContactMenu(from, phone);
          break;

        case 'SWAP_USDC':
          await this.handleSwapUSDC(from, phone);
          break;

        case 'DEPOSIT_FUNDS':
          await this.handleDepositFunds(from, phone);
          break;

        case 'DEPOSIT_ETH':
          await this.handleDepositETH(from, phone);
          break;

        case 'DEPOSIT_USDC':
          await this.handleDepositUSDC(from, phone);
          break;
          
        case 'ADD_CONTACT':
          await contactHandler.handleAddContact(from, phone, parameters);
          break;
          
        case 'LIST_CONTACTS':
          await contactHandler.handleListContacts(from, phone);
          break;

        case 'CLAIM':
          await this.handleClaimFlow(from, phone, parameters.token);
          break;

        case 'MAINNET_STATUS':
          await this.handleMainnetStatus(from, phone);
          break;
          
        default:
          await this.sendMessage(from, this.getUnknownCommandResponse());
      }
      
      logUserAction(phone, 'command_executed', { intent, success: true });
      
    } catch (error) {
      logger.error(`Error executing command ${intent}:`, error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
      logUserAction(phone, 'command_executed', { intent, success: false, error: error.message });
    }
  }

  // Handle claim flow when user sends CLAIM <TOKEN>
  async handleClaimFlow(from, phone, tokenPlain) {
    try {
      logger.info(`Claim attempt: ${phone} with token: ${tokenPlain?.substring(0, 8)}...`);
      
      // Ensure user has wallet; if not, prompt and exit
      const hasWallet = await walletHandler.validateUserWallet(phone);
      if (!hasWallet) {
        logger.info(`User ${phone} has no wallet, prompting wallet creation`);
        await this.sendMessage(from, `üåü *Welcome! You have ETH waiting to claim!* üåü\n\nTo receive your ETH, you need a wallet. Would you like me to:\n\nüÜï *Create a new wallet* (recommended for beginners)\nüì• *Import an existing wallet*\n\nReply with "create wallet" or "import wallet" to continue.`);
        return;
      }
      
      const wallet = await walletHandler.getUserWallet(phone);
      logger.info(`User ${phone} has wallet: ${wallet.address}`);
      
      const result = await claimsService.validateAndClaim({ 
        tokenPlain, 
        claimerPhone: phone, 
        recipientWalletAddress: wallet.address 
      });
      
      logger.info(`Claim successful for ${phone}: ${result.transferAmount} ETH`);
      
      await this.sendMessage(from, `‚úÖ *Claimed Successfully!*

üí∞ *Amount Received:* ${result.transferAmount.toFixed(6)} ETH
‚õΩ *Gas Fee:* ${result.gasCost.toFixed(6)} ETH
üîó *Transaction Hash:* \`${result.tx.hash}\`
üìä *View on Fuji Testnet:* https://testnet.snowtrace.io/tx/${result.tx.hash}

*Note: Gas fees were deducted from the held amount to complete your claim.*`);
      
    } catch (error) {
      logger.error(`Claim failed for ${phone}:`, error);
      
      // Provide better error messages based on error type
      if (error.message.includes('Amount too small')) {
        await this.sendMessage(from, `‚ùå *Claim Failed - Amount Too Small*

${error.message}

üí° *Solutions:*
‚Ä¢ Ask sender to send more ETH
‚Ä¢ Wait for lower network congestion
‚Ä¢ Contact sender for assistance

‚õΩ *Gas fees vary with network activity*`);
      } else if (error.message.includes('gas fees')) {
        await this.sendMessage(from, `‚ùå *Claim Failed - Gas Fee Issue*

${error.message}

üí° *What happened:*
‚Ä¢ Network gas fees are higher than expected
‚Ä¢ Available amount is too small to cover fees

üîÑ *Try again:*
‚Ä¢ Ask sender to send at least 0.005 ETH
‚Ä¢ Or try again during off-peak hours`);
      } else {
        await this.sendMessage(from, `‚ùå *Unable to claim:* ${error.message}\n\nüîç *Possible reasons:*\n‚Ä¢ Link expired or already used\n‚Ä¢ Wrong phone number\n‚Ä¢ Insufficient funds for gas fees\n‚Ä¢ Technical issue\n\nüí° *Need help?* Contact support or ask the sender to resend the claim link.`);
      }
    }
  }
  
  // Handle wallet creation flow
  async handleCreateWallet(from, phone) {
    try {
      // Check if user already has a testnet wallet
      const existingUser = await users.findUserByPhone(phone);
      if (existingUser) {
        const message = existingUser.mainnet_migrated 
          ? '‚úÖ You already have a testnet wallet! Your mainnet wallet is safely preserved.\n\nUse `/balance` to check your testnet balance or `/backup` to export your testnet private key.'
          : '‚ùå You already have a wallet! Use `/backup` to export your private key.';
        await this.sendMessage(from, message);
        return;
      }
      
      // Check if user is a mainnet user
      const isMainnetUser = await testnetMigration.isMainnetUser(phone);
      
      if (isMainnetUser) {
        // Show special welcome message for mainnet users
        const mainnetUserData = await testnetMigration.getMainnetUser(phone);
        const welcomeMessage = `üè¶ *Welcome back to ZAPPO!*

üîÑ *Testnet Mode Active*

Your mainnet wallet is safe and will be restored when we return to mainnet. For now, let's explore ZAPPO on testnet!

üìä *Your Mainnet Wallet:*
‚Ä¢ Address: \`${mainnetUserData?.wallet_address || 'Unknown'}\`
‚Ä¢ This wallet is preserved and secure

üß™ *Creating your testnet wallet now...*`;

        await this.sendMessage(from, welcomeMessage);
      } else {
        await this.sendMessage(from, 'üîÑ Creating your wallet... This may take a moment.');
      }
      
      const result = await walletHandler.createWallet(phone);
      
      if (result.success) {
        if (result.isMainnetUser) {
          // Special success message for migrated users
          await this.sendMessage(from, `‚úÖ *Testnet Wallet Created!*

üß™ *Your Testnet Wallet:*
‚Ä¢ Address: \`${result.walletAddress}\`
‚Ä¢ Ready for testnet transactions

üíß *Get Free Testnet ETH:*
üîó [arbitrum Faucet](https://arbitrum.faucet.dev/ArbSepolia)
‚Ä¢ Visit the faucet to get free testnet ETH
‚Ä¢ Use your new testnet address above

üè¶ *Your Mainnet Wallet:*
‚Ä¢ Address: \`${result.mainnetAddress}\`
‚Ä¢ Safe and will be restored later

Try these testnet commands:
‚Ä¢ \`/balance\` - Check testnet balance
‚Ä¢ \`/backup\` - Export testnet private key
‚Ä¢ \`/help\` - See all commands`);
        } else {
          // Regular success message for new users
          await this.sendMessage(from, `‚úÖ *Wallet Created Successfully!*

üè¶ Your wallet is now ready to use! Try:
‚Ä¢ \`/balance\` - Check your balance
‚Ä¢ \`/backup\` - Export your private key
‚Ä¢ \`/help\` - See all commands

ÔøΩ *Get Free Testnet ETH:*
üîó [arbitrum Faucet](https://arbitrum.faucet.dev/ArbSepolia)

üí° *This is testnet mode - perfect for  testing!*`);
        }
        
        // Send wallet address as separate message for easy copying
        await this.sendMessage(from, `üìã *Your Testnet Wallet Address:*\n\`${result.walletAddress}\`\n\n*Tap to copy this address for the faucet!*`);
      } else {
        await this.sendMessage(from, `‚ùå Failed to create wallet: ${result.error}`);
      }
      
    } catch (error) {
      logger.error('Error creating wallet:', error);
      await this.sendMessage(from, `‚ùå Error creating wallet: ${error.message}`);
    }
  }
  
  // Handle greeting messages
  async handleGreeting(from, phone) {
    try {
      // Check if user has a wallet
      const existingUser = await users.findUserByPhone(phone);
      
      if (!existingUser) {
        // New user - send welcome message
        await this.sendMessage(from, this.getWelcomeMessage());
        return;
      }
      
      // Existing user - show fancy options
      const wallet = await walletHandler.getUserWallet(phone);
      if (wallet) {
        // Get fresh balance from blockchain
        const freshBalance = await nebulaService.getBalance(wallet.address);
        const balanceValue = parseFloat(freshBalance.balance) || 0;
        
        await this.sendMessage(from, `üëã *Hey there, Crypto Explorer!* üöÄ

üí∞ *Balance:* ${balanceValue.toFixed(6)} ETH (Testnet)

üéØ *What's your next move?*

üí∏ **Send Funds to Friends**
   ‚Ä¢ Quick transfers to contacts
   ‚Ä¢ Share crypto instantly
   ‚Ä¢ Type: "send funds"

üåä **Explore DeFi**
   ‚Ä¢ Check your balance & history
   ‚Ä¢ View transaction details  
   ‚Ä¢ Type: "explore defi"

üÜò **Need Help?**
   ‚Ä¢ Type "help" for all commands

üß™ *Testnet Mode - Safe to experiment!*`);
      } else {
        // User exists but no wallet - shouldn't happen, but handle gracefully
        await this.sendMessage(from, `üëã Hello! It seems there was an issue with your wallet. Please type "create wallet" to set up a new one.`);
      }
      
    } catch (error) {
      logger.error('Error handling greeting:', error);
      await this.sendMessage(from, `üëã Hello! Welcome to ZAPPO. Type "help" to see what I can do!`);
    }
  }
  
  // Handle wallet import flow
  async handleImportWallet(from, phone) {
    try {
      // Check if user already has a wallet
      const existingUser = await users.findUserByPhone(phone);
      if (existingUser) {
        await this.sendMessage(from, 'You already have a wallet set up. You can export your private key anytime with /backup.');
        return;
      }
      
      // Set user state to expect private key
      this.userStates.set(phone, {
        state: 'IMPORTING_WALLET',
        timestamp: Date.now()
      });
      
      await this.sendMessage(from, `Let‚Äôs import your wallet.

Please paste your private key here to proceed.

Security tips:
- Share your private key only in this chat.
- Never share it with anyone else.
- We‚Äôll encrypt it securely.

You can type cancel to stop anytime.`);
      
    } catch (error) {
      logger.error('Error starting wallet import:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Send Funds" menu option
  async handleSendFundsMenu(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      await this.sendMessage(from, `üí∏ *Send Funds to Friends* üöÄ

Choose how you want to send:

üì± **Send to Contact**
   ‚Ä¢ Pick from your WhatsApp contacts
   ‚Ä¢ Type: "send to contact"

üí∞ **Send Specific Amount**
   ‚Ä¢ Send ETH to any address
   ‚Ä¢ Type: "send 0.1 ETH to 0x..."

üì≤ **Quick Send**
   ‚Ä¢ Share contact and I'll ask for amount
   ‚Ä¢ Just share a contact!

üí° **Tips:**
   ‚Ä¢ All transactions are on testnet
   ‚Ä¢ Gas fees are very low
   ‚Ä¢ Type "balance" to check funds first

üîô Type "hi" to go back to main menu`);
      
    } catch (error) {
      logger.error('Error handling send funds menu:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Send to Contact" option
  async handleSendToContactMenu(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      // Set user state to await contact sharing
      this.userStates.set(phone, {
        state: 'AWAITING_CONTACT_FOR_SEND',
        timestamp: Date.now()
      });

      await this.sendMessage(from, `üì± *Send to WhatsApp Contact* üöÄ

Please share a contact from your WhatsApp:

1Ô∏è‚É£ Tap the üìé (attachment) button
2Ô∏è‚É£ Select "Contact"  
3Ô∏è‚É£ Choose the person you want to send ETH to
4Ô∏è‚É£ Send the contact

I'll then ask you how much ETH to send! 

üí° *Tip:* The person doesn't need ZAPPO yet - they'll get a claim link to receive the funds.

üîô Type "cancel" to go back`);
      
    } catch (error) {
      logger.error('Error handling send to contact menu:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Explore DeFi" menu option  
  async handleExploreDeFiMenu(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      // Set user state to await DeFi menu selection
      this.userStates.set(phone, {
        state: 'AWAITING_DEFI_SELECTION',
        timestamp: Date.now()
      });

      const wallet = await walletHandler.getUserWallet(phone);
      
      await this.sendMessage(from, `üåä *ZAPPO DeFi Hub* üè¶

üîπ **Your Wallet:** \`${wallet?.address?.slice(0,6)}...${wallet?.address?.slice(-4)}\`
üîπ **Network:** Arbitrum Sepolia

üìã **Choose an option:**

*1Ô∏è‚É£ Swap Tokens*
   Exchange ETH ‚Üî USDC at best rates

*2Ô∏è‚É£ Deposit USDC*
   Earn ZAP tokens (1 USDC = 1 ZAP)

*3Ô∏è‚É£ Check Balance* 
   View your token balances

*4Ô∏è‚É£ Transaction History*
   See your recent DeFi activity

üéØ **Reply with a number (1-4) to continue** ÔøΩ

Your DeFi Dashboard:

ÔøΩ **Swap Tokens**
   ‚Ä¢ Swap ETH ‚Üî USDC
   ‚Ä¢ Best rates on Arbitrum
   ‚Ä¢ Type: "swap usdc"

üè¶ **Deposit to Vault**
   ‚Ä¢ Earn yield on your ETH
   ‚Ä¢ Secure lending protocols
   ‚Ä¢ Type: "deposit funds"

üìä **Portfolio Management**
   ‚Ä¢ "balance" - Check current balance
   ‚Ä¢ "history" - View recent transactions

üîç **Wallet Details**
   ‚Ä¢ Address: \`${wallet?.address || 'Loading...'}\`
   ‚Ä¢ Network: Arbitrum Sepolia (Testnet)

üéØ **Quick Actions:**
   ‚Ä¢ "swap usdc" - Exchange ETH for USDC
   ‚Ä¢ "deposit funds" - Earn yield on deposits
   ‚Ä¢ "balance" - Check current balance
   ‚Ä¢ "history" - View transaction history

üß™ **Testnet Info:**
   ‚Ä¢ Practice DeFi safely with testnet tokens
   ‚Ä¢ No real money involved
   ‚Ä¢ Perfect for learning!

üîô Type "back" to return to main menu`);
      
    } catch (error) {
      logger.error('Error handling explore DeFi menu:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Swap USDC" option
  async handleSwapUSDC(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      const wallet = await walletHandler.getUserWallet(phone);
      const freshBalance = await nebulaService.getBalance(wallet.address);
      const ethBalance = parseFloat(freshBalance.balance) || 0;

      await this.sendMessage(from, `üí± *Swap ETH ‚Üî USDC* üîÑ

Current Balance: ${ethBalance.toFixed(6)} ETH

üîÑ **Swap Options:**

üì§ **ETH ‚Üí USDC**
   ‚Ä¢ Convert ETH to USDC stablecoin
   ‚Ä¢ Get stable value exposure
   ‚Ä¢ Type: "swap eth to usdc"

üì• **USDC ‚Üí ETH**
   ‚Ä¢ Convert USDC back to ETH
   ‚Ä¢ Re-enter ETH exposure
   ‚Ä¢ Type: "swap usdc to eth"

üí° **Swap Benefits:**
   ‚Ä¢ Instant swaps via Uniswap V3
   ‚Ä¢ Best rates on Arbitrum
   ‚Ä¢ Low gas fees on testnet

‚ö†Ô∏è **Coming Soon:**
   This feature is being integrated with DEX protocols. 
   For now, you can practice with direct ETH transfers!

üéØ **Alternative Actions:**
   ‚Ä¢ "send eth" - Send ETH to contacts
   ‚Ä¢ "balance" - Check current balance

üîô Type "hi" to go back to main menu`);
      
    } catch (error) {
      logger.error('Error handling swap USDC:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Deposit Funds" option
  async handleDepositFunds(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      const wallet = await walletHandler.getUserWallet(phone);
      const freshBalance = await nebulaService.getBalance(wallet.address);
      const ethBalance = parseFloat(freshBalance.balance) || 0;

      await this.sendMessage(from, `üè¶ *Deposit to Yield Vault* üí∞

Current Balance: ${ethBalance.toFixed(6)} ETH

üíé **Yield Opportunities:**

üèõÔ∏è **ETH Lending Pool**
   ‚Ä¢ Earn 3-5% APY on ETH deposits
   ‚Ä¢ Withdraw anytime
   ‚Ä¢ Type: "deposit eth"

üíµ **USDC Vault**
   ‚Ä¢ Stable 4-6% APY
   ‚Ä¢ Lower risk option
   ‚Ä¢ Type: "deposit usdc"

üìà **Strategy Vaults**
   ‚Ä¢ Auto-compounding yields
   ‚Ä¢ 8-12% APY potential
   ‚Ä¢ Type: "strategy vault"

üí° **Vault Benefits:**
   ‚Ä¢ Professional yield farming
   ‚Ä¢ Automated strategies
   ‚Ä¢ Secure smart contracts

‚ö†Ô∏è **Coming Soon:**
   Vault integrations with Aave, Compound, and other protocols are being implemented!
   
üéØ **Current Options:**
   ‚Ä¢ Practice with testnet funds
   ‚Ä¢ Learn DeFi concepts safely
   ‚Ä¢ "send eth" for peer transfers

üîô Type "hi" to go back to main menu`);
      
    } catch (error) {
      logger.error('Error handling deposit funds:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Deposit ETH" command
  async handleDepositETH(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      await this.sendMessage(from, `‚ö†Ô∏è *ETH Deposit Coming Soon!* üöß

ETH deposits to earn ZAP tokens are being integrated.

üéØ **Available Now:**
   ‚Ä¢ "deposit usdc" - Deposit USDC to earn ZAP tokens
   ‚Ä¢ "balance" - Check your current balance

üîô Type "hi" to go back to main menu`);
      
    } catch (error) {
      logger.error('Error handling ETH deposit:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Swap Tokens" command
  async handleSwapTokens(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      // Set user state to await amount input
      this.userStates.set(phone, {
        state: 'AWAITING_SWAP_AMOUNT',
        timestamp: Date.now()
      });

      // Get current balances to show user
      const balanceData = await getTokenBalances();

      await this.sendMessage(from, `üîÑ *Swap USDC to WETH* üí±

üîπ **Current Balances:**
‚Ä¢ USDC: ${balanceData.usdcBalance || '0.00'} USDC
‚Ä¢ WETH: ${parseFloat(balanceData.wethBalance || '0').toFixed(6)} WETH

üí± **Exchange Rate:** Market rate via Uniswap V3

üéØ **How much USDC would you like to swap?**

Examples:
‚Ä¢ Type "1" for 1 USDC
‚Ä¢ Type "0.5" for 0.5 USDC  
‚Ä¢ Type "5" for 5 USDC

üí° **Swap Features:**
‚Ä¢ Best rates on Arbitrum
‚Ä¢ Instant execution
‚Ä¢ Low gas fees

üîô Type "cancel" to go back`);
      
    } catch (error) {
      logger.error('Error handling swap tokens:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle "Deposit USDC" command
  async handleDepositUSDC(from, phone) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }

      // Set user state to await amount input
      this.userStates.set(phone, {
        state: 'AWAITING_USDC_DEPOSIT_AMOUNT',
        timestamp: Date.now()
      });

      await this.sendMessage(from, `üí∞ *Deposit USDC to Earn ZAP Tokens* üè¶

üí± **Current Rate:** 1 USDC = 1 ZAP token

üéØ **How much USDC would you like to deposit?**

Examples:
‚Ä¢ Type "1" for 1 USDC
‚Ä¢ Type "0.5" for 0.5 USDC  
‚Ä¢ Type "10" for 10 USDC

üí° **Benefits:**
‚Ä¢ Instant ZAP token rewards
‚Ä¢ 1:1 conversion rate
‚Ä¢ Secure smart contract

üîô Type "cancel" to go back`);
      
    } catch (error) {
      logger.error('Error handling USDC deposit:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }
  
  // Handle send transaction flow
  async handleSendTransaction(from, phone, parameters) {
    try {
      // Check if user has a wallet
      const user = await users.findUserByPhone(phone);
      if (!user) {
        await this.sendMessage(from, '‚ùå You need to create a wallet first! Send "create wallet" to get started.');
        return;
      }
      
      let sendParams;
      
      if (parameters.amount && (parameters.recipient || parameters.recipientPhone)) {
        // Direct parameters from regex match or phone-based flows
        sendParams = {
          amount: parameters.amount,
          recipient: parameters.recipient,
          recipientPhone: parameters.recipientPhone,
          name: parameters.name, // Preserve the name parameter
          valid: true
        };
      } else if (parameters.args) {
        // Parse from command arguments
        sendParams = commandParser.parseSendParameters(parameters.args);
      } else if (parameters.intent === 'SEND_ARB_START') {
        // Multi-step flow: user just typed "send ETH"
        this.userStates.set(phone, {
          state: 'AWAITING_CONTACT_FOR_SEND',
          timestamp: Date.now()
        });
        await this.sendMessage(from, `üì± *Send Testnet ETH - Step 1: Contact* üß™\n\nPlease share the contact you want to send testnet ETH to.\n\nYou can:\n‚Ä¢ Share a contact from your phone\n‚Ä¢ Or type the phone number (e.g., 919489042245)\n\nüß™ *Note:* This uses testnet ETH - no real money!\n\nType "cancel" to stop.`);
        return;
      } else {
        await this.sendMessage(from, '‚ùå Invalid send format. Try: "send 1 ETH to 0x..." or just type "send ETH" for step-by-step.');
        return;
      }
      
      if (!sendParams.valid) {
        await this.sendMessage(from, `‚ùå ${sendParams.error}`);
        return;
      }
      
      // Validate amount
      if (!commandParser.validateAmount(sendParams.amount)) {
        await this.sendMessage(from, '‚ùå Invalid amount. Please enter a valid amount between 0.000001 and 1,000,000 ETH.');
        return;
      }
      
      // Process the transaction
      await transactionHandler.handleSendTransaction(from, phone, sendParams);
      
    } catch (error) {
      logger.error('Error handling send transaction:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }
  
  // Handle transaction confirmation responses
  async handleTransactionConfirmation(from, phone, text) {
    try {
      const pendingTx = this.pendingTransactions.get(phone);
      
      if (!pendingTx) {
        await this.sendMessage(from, '‚ùå No pending transaction found.');
        return;
      }
      
      // Handle confirmations
      if (commandParser.isConfirmation(text)) {
        // User confirmed the transaction
        logger.info(`Transaction confirmed by ${phone} with: ${text}`);
        this.pendingTransactions.delete(phone);
        
        // Check transaction type
        if (pendingTx.type === 'usdc_deposit') {
          await this.executeUSDCDeposit(from, phone, pendingTx);
        } else if (pendingTx.type === 'usdc_swap') {
          await this.executeUSDCSwap(from, phone, pendingTx);
        } else {
          // Regular transaction
          await transactionHandler.executePendingTransaction(from, phone, pendingTx);
        }
        
      } else if (commandParser.isCancellation(text)) {
        // User cancelled the transaction
        logger.info(`Transaction cancelled by ${phone} with: ${text}`);
        this.pendingTransactions.delete(phone);
        
        if (pendingTx.type === 'usdc_deposit') {
          await this.sendMessage(from, '‚ùå USDC deposit cancelled.');
        } else if (pendingTx.type === 'usdc_swap') {
          await this.sendMessage(from, '‚ùå USDC swap cancelled.');
        } else {
          await this.sendMessage(from, '‚ùå Transaction cancelled.');
        }
        
      } else {
        // Invalid response
        logger.info(`Invalid confirmation response from ${phone}: ${text}`);
        
        if (pendingTx.type === 'usdc_deposit') {
          await this.sendMessage(from, '‚ùì Please reply "yes" to confirm your USDC deposit or "no" to cancel.');
        } else if (pendingTx.type === 'usdc_swap') {
          await this.sendMessage(from, '‚ùì Please reply "yes" to confirm your USDC swap or "no" to cancel.');
        } else {
          await this.sendMessage(from, '‚ùì Please react with üëç to confirm or üëé to cancel the transaction.');
        }
      }
      
    } catch (error) {
      logger.error('Error handling transaction confirmation:', error);
      this.pendingTransactions.delete(phone);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }
  
  // Handle stateful messages (wallet import, etc.)
  async handleStatefulMessage(from, phone, text) {
    try {
      const msg = (text ?? '').toString().trim();
      const userState = this.userStates.get(phone);
      
      if (msg.toLowerCase() === 'cancel') {
        this.userStates.delete(phone);
        await this.sendMessage(from, '‚ùå Operation cancelled.');
        return;
      }
      
      // If there is no active state, guide the user instead of crashing
      if (!userState) {
        await this.sendMessage(from, 'There‚Äôs no active action to continue. Please start again (e.g., share a contact or type a command).');
        return;
      }

      // Check if state has expired (5 minutes)
      if (Date.now() - userState.timestamp > 5 * 60 * 1000) {
        this.userStates.delete(phone);
        await this.sendMessage(from, '‚è∞ Operation timed out. Please try again.');
        return;
      }
      
      switch (userState.state) {
        case 'IMPORTING_WALLET':
          await this.handlePrivateKeyInput(from, phone, text);
          break;
          
        case 'AWAITING_DEFI_SELECTION': {
          const selection = msg.trim();
          this.userStates.delete(phone);
          
          switch(selection) {
            case '1':
              await this.handleSwapTokens(from, phone);
              break;
            case '2':
              await this.handleDepositUSDC(from, phone);
              break;
            case '3':
              await transactionHandler.handleBalance(from, phone);
              break;
            case '4':
              await transactionHandler.handleHistory(from, phone);
              break;
            case 'back':
              await this.handleGreeting(from, phone);
              break;
            default:
              await this.sendMessage(from, '‚ùå Please select a valid option (1-4) or type "back"');
              await this.handleExploreDeFiMenu(from, phone);
          }
          break;
        }
          
        case 'AWAITING_AMOUNT_FOR_CONTACT': {
          const amount = parseFloat(msg);
          if (!isNaN(amount) && amount > 0) {
            const target = userState.targetAddress;
            const contactName = userState.contactName;
            const contactPhone = userState.contactPhone;
            this.userStates.delete(phone);
            await this.handleSendTransaction(from, phone, { 
              amount, 
              recipient: target, 
              name: contactName,
              recipientPhone: contactPhone 
            });
          } else {
            await this.sendMessage(from, '‚ùå Please enter a valid ETH amount (e.g., 0.1).');
          }
          break;
        }
        case 'AWAITING_AMOUNT_FOR_UNREGISTERED': {
          const amount = parseFloat(msg);
          if (!isNaN(amount) && amount > 0) {
            const recipientPhone = userState.recipientPhone;
            this.userStates.delete(phone);
            // Route through send flow; it will detect phone-like recipient and use claim-link escrow
            await this.handleSendTransaction(from, phone, { 
              amount, 
              recipientPhone: recipientPhone, // Use recipientPhone for unregistered users
              name: recipientPhone 
            });
          } else {
            await this.sendMessage(from, '‚ùå Please enter a valid ETH amount (e.g., 0.1).');
          }
          break;
        }
        case 'AWAITING_CONTACT_FOR_SEND': {
          // User provided contact, now ask for amount
          this.userStates.set(phone, {
            state: 'AWAITING_AMOUNT_FOR_SEND',
            recipientPhone: msg,
            timestamp: Date.now()
          });
          await this.sendMessage(from, `üì± *Send Testnet ETH - Step 2: Amount* üß™\n\nHow much testnet ETH would you like to send to ${msg}?\n\nPlease enter the amount (e.g., 0.1, 1.5, 10)\n\nüß™ *Note:* This is testnet ETH - safe to test!\n\nType "cancel" to stop.`);
          break;
        }
        case 'AWAITING_AMOUNT_FOR_SEND': {
          const amount = parseFloat(msg);
          if (!isNaN(amount) && amount > 0) {
            const recipientPhone = userState.recipientPhone;
            this.userStates.delete(phone);
            // Route through send flow; it will detect phone-like recipient and use claim-link escrow
            await this.handleSendTransaction(from, phone, { 
              amount, 
              recipientPhone: recipientPhone, // Use recipientPhone for manual phone entry
              name: recipientPhone 
            });
          } else {
            await this.sendMessage(from, '‚ùå Please enter a valid ETH amount (e.g., 0.1).');
          }
          break;
        }

        case 'AWAITING_USDC_DEPOSIT_AMOUNT': {
          const amount = parseFloat(msg);
          if (!isNaN(amount) && amount > 0) {
            this.userStates.delete(phone);
            await this.handleDepositConfirmation(from, phone, amount);
          } else {
            await this.sendMessage(from, '‚ùå Please enter a valid USDC amount (e.g., 1, 0.5, 10).');
          }
          break;
        }

        case 'AWAITING_SWAP_AMOUNT': {
          const amount = parseFloat(msg);
          if (!isNaN(amount) && amount > 0) {
            this.userStates.delete(phone);
            await this.handleSwapConfirmation(from, phone, amount);
          } else if (msg.toLowerCase() === 'cancel') {
            this.userStates.delete(phone);
            await this.handleExploreDeFiMenu(from, phone);
          } else {
            await this.sendMessage(from, '‚ùå Please enter a valid USDC amount (e.g., 1, 0.5, 5).');
          }
          break;
        }
          
        default:
          this.userStates.delete(phone);
          await this.sendMessage(from, '‚ùå Invalid state. Please try again.');
      }
      
    } catch (error) {
      logger.error('Error handling stateful message:', error);
      this.userStates.delete(phone);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle deposit confirmation
  async handleDepositConfirmation(from, phone, amount) {
    try {
      const wallet = await walletHandler.getUserWallet(phone);
      if (!wallet) {
        await this.sendMessage(from, '‚ùå Wallet not found. Please create a wallet first.');
        return;
      }

      // Get current balances
      let currentUSDCBalance = 0;
      let currentZAPBalance = 0;
      
      try {
        // Get current USDC balance from smart contract
        const balances = await checkBalances();
        if (balances && balances.usdc) {
          currentUSDCBalance = parseFloat(balances.usdc);
        }
        
        // Get current ZAP balance
        const zapBalance = await getZAPBalance();
        const formattedZapBalance = (parseFloat(zapBalance) * 1e18).toFixed(0);
        currentZAPBalance = parseInt(formattedZapBalance);
      } catch (error) {
        logger.warn('Could not fetch current balances:', error.message);
      }

      // Calculate what user will receive (1:1 ratio for display)
      const zapTokensToReceive = amount;
      const newZAPBalance = currentZAPBalance + (amount * 1e18); // Estimate new balance

      const confirmMessage = `üí∞ *USDC Deposit Confirmation* üè¶

ÔøΩ *Current Holdings:*
‚Ä¢ USDC Balance: ${currentUSDCBalance.toFixed(4)} USDC
‚Ä¢ ZAP Balance: ${currentZAPBalance.toLocaleString()} ZAP

üì• *Deposit Details:*
‚Ä¢ Amount: ${amount} USDC
‚Ä¢ Rate: 1 USDC = 1 ZAP token
‚Ä¢ You'll Receive: ${zapTokensToReceive} ZAP tokens

ÔøΩ *After Deposit:*
‚Ä¢ New USDC Balance: ${(currentUSDCBalance - amount).toFixed(4)} USDC
‚Ä¢ New ZAP Balance: ${newZAPBalance.toLocaleString()} ZAP

‚ö° *Transaction Info:*
‚Ä¢ Processing: Instant via smart contract
‚Ä¢ Security: Fully audited contract
‚Ä¢ Network: Arbitrum Sepolia testnet

*Reply "yes" to confirm or "no" to cancel*

‚è±Ô∏è This confirmation expires in 5 minutes`;

      await this.sendMessage(from, confirmMessage);

      // Store pending deposit
      this.pendingTransactions.set(phone, {
        type: 'usdc_deposit',
        amount: amount,
        zapTokens: zapTokensToReceive,
        timestamp: Date.now()
      });

    } catch (error) {
      logger.error('Error handling deposit confirmation:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Handle swap confirmation
  async handleSwapConfirmation(from, phone, amount) {
    try {
      const wallet = await walletHandler.getUserWallet(phone);
      if (!wallet) {
        await this.sendMessage(from, '‚ùå Wallet not found. Please create a wallet first.');
        return;
      }

      // Get quote and current balances
      const quoteResult = await getSwapQuote(amount);
      
      if (!quoteResult.success) {
        await this.sendMessage(from, `‚ùå ${quoteResult.error}\n\nüîô Type "1" to try a different amount`);
        return;
      }

      const currentUSDCBalance = parseFloat(quoteResult.currentUSDCBalance);
      const wethToReceive = parseFloat(quoteResult.amountOut);

      // Get current WETH balance
      let currentWETHBalance = 0;
      try {
        const balanceData = await getTokenBalances();
        if (balanceData && balanceData.wethBalance) {
          currentWETHBalance = parseFloat(balanceData.wethBalance);
        }
      } catch (error) {
        logger.warn('Could not fetch WETH balance:', error.message);
      }

      const confirmMessage = `üîÑ *USDC to WETH Swap Confirmation* üí±

üìä *Current Holdings:*
‚Ä¢ USDC Balance: ${currentUSDCBalance.toFixed(4)} USDC
‚Ä¢ WETH Balance: ${currentWETHBalance.toFixed(6)} WETH

üîÑ *Swap Details:*
‚Ä¢ Input: ${amount} USDC
‚Ä¢ Output: ~${wethToReceive.toFixed(6)} WETH
‚Ä¢ Rate: Market rate via Uniswap V3

üìà *After Swap:*
‚Ä¢ New USDC Balance: ${(currentUSDCBalance - amount).toFixed(4)} USDC
‚Ä¢ New WETH Balance: ${(currentWETHBalance + wethToReceive).toFixed(6)} WETH

‚ö° *Transaction Info:*
‚Ä¢ Processing: Instant via Uniswap V3
‚Ä¢ Slippage: 5% maximum
‚Ä¢ Network: Arbitrum Sepolia

*Reply "yes" to confirm or "no" to cancel*

‚è±Ô∏è This confirmation expires in 5 minutes`;

      await this.sendMessage(from, confirmMessage);

      // Store pending swap
      this.pendingTransactions.set(phone, {
        type: 'usdc_swap',
        amount: amount,
        expectedOutput: wethToReceive,
        timestamp: Date.now()
      });

    } catch (error) {
      logger.error('Error handling swap confirmation:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Execute USDC deposit
  async executeUSDCDeposit(from, phone, depositData) {
    try {
      const { amount, zapTokens } = depositData;

      await this.sendMessage(from, `‚è≥ *Processing Deposit...* 

üí∞ Depositing ${amount} USDC to vault...
üîÑ Smart contract execution in progress...

Please wait while we process your transaction...`);

      // Execute the actual deposit using connections.js
      try {
        await deposit(amount);
        
        // Log the successful deposit
        logUserAction(phone, 'usdc_deposit', { 
          usdcAmount: amount, 
          zapTokens: zapTokens,
          success: true 
        });

        // Send success message with 1:1 display ratio
        await this.sendMessage(from, `‚úÖ *Deposit Successful!* üéâ

üí∞ **Deposited:** ${amount} USDC
üìà **Received:** ${zapTokens} ZAP tokens
üí± **Rate:** 1:1 conversion

üéØ **Your ZAP Tokens:**
‚Ä¢ Total ZAP earned: ${zapTokens}
‚Ä¢ Earning potential: Active
‚Ä¢ Withdraw anytime

üåä **Next Steps:**
‚Ä¢ Type "balance" to check updated balance
‚Ä¢ Type "explore defi" for more DeFi options
‚Ä¢ Type "deposit usdc" to deposit more

üéä Welcome to the ZAP ecosystem!`);

      } catch (error) {
        logger.error('Deposit execution failed:', error);
        
        // Log the failed deposit
        logUserAction(phone, 'usdc_deposit', { 
          usdcAmount: amount, 
          zapTokens: zapTokens,
          success: false,
          error: error.message 
        });

        await this.sendMessage(from, `‚ùå *Deposit Failed* 

The deposit transaction could not be completed.

**Possible reasons:**
‚Ä¢ Network congestion
‚Ä¢ Insufficient funds in vault contract
‚Ä¢ Temporary technical issue

**Please try again or contact support.**

üîô Type "deposit usdc" to try again`);
      }

    } catch (error) {
      logger.error('Error executing USDC deposit:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }

  // Execute USDC to WETH swap
  async executeUSDCSwap(from, phone, swapData) {
    try {
      const { amount, expectedOutput } = swapData;

      await this.sendMessage(from, `‚è≥ *Processing Swap...* 

üîÑ Swapping ${amount} USDC for WETH...
üåä Uniswap V3 execution in progress...

Please wait while we process your transaction...`);

      // Execute the actual swap using swapService.js
      try {
        const swapResult = await swapUSDCtoWETH(amount);
        
        if (!swapResult.success) {
          throw new Error(swapResult.error);
        }
        
        // Log the successful swap
        logUserAction(phone, 'usdc_swap', { 
          usdcAmount: amount, 
          wethReceived: swapResult.amountOut,
          transactionHash: swapResult.transactionHash,
          success: true 
        });

        // Send success message
        await this.sendMessage(from, `‚úÖ *Swap Successful!* üéâ

üîÑ **Swapped:** ${amount} USDC ‚Üí ${swapResult.amountOut} WETH
üí± **Rate:** Market rate via Uniswap V3
üîó **Transaction:** https://sepolia.arbiscan.io/tx/${swapResult.transactionHash}

üìä **Updated Balances:**
‚Ä¢ USDC: ${swapResult.newUSDCBalance} USDC
‚Ä¢ WETH: ${swapResult.newWETHBalance} WETH

üåä **Next Steps:**
‚Ä¢ Type "balance" to check updated balance
‚Ä¢ Type "1" to swap more tokens
‚Ä¢ Type "explore defi" for more DeFi options

üéä Happy trading!`);

      } catch (error) {
        logger.error('Swap execution failed:', error);
        
        // Log the failed swap
        logUserAction(phone, 'usdc_swap', { 
          usdcAmount: amount, 
          expectedOutput: expectedOutput,
          success: false,
          error: error.message 
        });

        await this.sendMessage(from, `‚ùå *Swap Failed* 

The swap transaction could not be completed.

**Error:** ${error.message}

**Possible reasons:**
‚Ä¢ Insufficient USDC balance
‚Ä¢ Low liquidity in pool
‚Ä¢ Network congestion
‚Ä¢ Slippage too high

**Please try again with a smaller amount.**

üîô Type "1" to try again`);
      }

    } catch (error) {
      logger.error('Error executing USDC swap:', error);
      await this.sendMessage(from, `‚ùå Error: ${error.message}`);
    }
  }
  
  // Handle private key input for wallet import
  async handlePrivateKeyInput(from, phone, privateKey) {
    try {
      // Validate private key format
      if (!privateKey.match(/^0x[a-fA-F0-9]{64}$/)) {
        await this.sendMessage(from, 'That doesn‚Äôt look like a valid private key. Please send a 64‚Äëcharacter hex key starting with 0x.');
        return;
      }
      
      await this.sendMessage(from, 'Importing your wallet‚Ä¶ this usually takes a moment.');
      
      const result = await walletHandler.importWallet(phone, privateKey);
      
      if (result.success) {
        this.userStates.delete(phone);
        await this.sendMessage(from, `Wallet imported successfully.

Address: \`${result.walletAddress}\`
Balance: ${result.balance} ETH

You‚Äôre all set. You can try:
- /balance to check your balance
- /history to view recent transactions
- /help to see all commands`);
      } else {
        await this.sendMessage(from, `Couldn‚Äôt import the wallet: ${result.error}`);
      }
      
    } catch (error) {
      logger.error('Error importing wallet:', error);
      this.userStates.delete(phone);
      await this.sendMessage(from, `We couldn‚Äôt complete the import: ${error.message}`);
    }
  }
  
  // Store pending transaction for confirmation
  storePendingTransaction(phone, transactionData) {
    this.pendingTransactions.set(phone, {
      ...transactionData,
      timestamp: Date.now()
    });
  }
  
  // Extract phone number from WhatsApp ID
  extractPhoneNumber(whatsappId) {
    // Remove @s.whatsapp.net suffix and country code if present
    return whatsappId.replace('@s.whatsapp.net', '').replace('@c.us', '');
  }
  
  // Send message helper
  async sendMessage(to, message) {
    try {
      // FIXED: Baileys expects message content as object, not string
      const messageContent = typeof message === 'string' 
        ? { text: message } 
        : message;

      // Normalize JID to ensure valid WhatsApp ID
      let jid = to || '';
      if (typeof jid === 'string') {
        if (!jid.includes('@')) {
          jid = `${jid.replace(/\D/g, '')}@s.whatsapp.net`;
        } else if (jid.endsWith('@c.us')) {
          jid = jid.replace('@c.us', '@s.whatsapp.net');
        }
      }

      // Route through our WhatsApp service to leverage queueing & connection checks
      await whatsappService.sendMessage(jid, messageContent);
    } catch (error) {
      logger.error('Error sending message:', error);
    }
  }
  
  // Get beautiful welcome message for first-time users
  getWelcomeMessage() {
    return `üåü *Welcome to ZAPPO!* üåü

üéâ *Your Personal Arbitrum Wallet on WhatsApp*

I'm here to help you manage your funds right from your phone! 

üíº *What would you like to do?*

üÜï *Create a New Wallet*
‚Ä¢ Type: "create wallet" or "new wallet"
‚Ä¢ I'll generate a secure wallet for you
‚Ä¢ Perfect for beginners

üì• *Import Existing Wallet*
‚Ä¢ Type: "import wallet" 
‚Ä¢ Use your private key to restore access
‚Ä¢ Great if you already have a wallet

üí∏ *Send ETH to Contacts*
‚Ä¢ Type: "send ETH" to start sending to your contacts
‚Ä¢ Easy transfers via WhatsApp contacts!

‚ùì *Need Help?*
‚Ä¢ Type: \`/help\` for all commands
‚Ä¢ Ask me anything about crypto!

üöÄ *Ready to get started?* Just let me know what you'd prefer!`;
  }

  // Get response for unknown commands
  getUnknownCommandResponse() {
    return `ü§ñ *ZAPPO - ETH Wallet Bot*

I didn't understand that command. Here are some things you can try:

‚Ä¢ \`/help\` - Show all commands
‚Ä¢ "create wallet" - Create a new wallet
‚Ä¢ "import wallet" - Import existing wallet
‚Ä¢ \`/balance\` - Check your balance
‚Ä¢ "send ETH" - Start sending ETH to contacts
‚Ä¢ "send 1 ETH to 0x..." - Send ETH to address

Need help? Type \`/help\` for a full list of commands!`;
  }

  // Check if command is admin-only
  isAdminCommand(text) {
    const command = text.toLowerCase().trim();
    return command === '/status' || command === '/reset' || command.startsWith('/admin');
  }

  // Handle admin commands with authorization
  async handleAdminCommand(from, phone, text) {
    // Define admin phone numbers (replace with actual admin numbers)
    const adminNumbers = [
      '919489042245', // Replace with actual admin phone numbers
      // Add more admin numbers as needed
    ];
    
    if (!adminNumbers.includes(phone)) {
      await this.sendMessage(from, '‚ùå Access denied. This command is restricted to administrators only.');
      logger.warn(`Unauthorized admin command attempt from ${phone}: ${text}`);
      return;
    }
    
    const command = text.toLowerCase().trim();
    
    try {
      switch (command) {
        case '/status':
          await this.handleStatusCommand(from, phone);
          break;
        case '/reset':
          await this.handleResetCommand(from, phone);
          break;
        default:
          await this.sendMessage(from, '‚ùå Unknown admin command. Available: /status, /reset');
      }
      
      logger.info(`Admin command executed by ${phone}: ${command}`);
      
    } catch (error) {
      logger.error(`Error executing admin command ${command}:`, error);
      await this.sendMessage(from, `‚ùå Error executing admin command: ${error.message}`);
    }
  }

  // Handle status command for admins
  async handleStatusCommand(from, phone) {
    try {
      const stats = {
        userStates: this.userStates.size,
        pendingTransactions: this.pendingTransactions.size,
        uptime: process.uptime(),
        memory: process.memoryUsage()
      };
      
      const response = `üîß *ZAPPO Admin Status*

üë• *Active User States:* ${stats.userStates}
‚è≥ *Pending Transactions:* ${stats.pendingTransactions}
‚è±Ô∏è *Uptime:* ${Math.floor(stats.uptime / 3600)}h ${Math.floor((stats.uptime % 3600) / 60)}m
üíæ *Memory Usage:* ${Math.round(stats.memory.heapUsed / 1024 / 1024)}MB / ${Math.round(stats.memory.heapTotal / 1024 / 1024)}MB

üïê *Timestamp:* ${new Date().toISOString()}`;

      await this.sendMessage(from, response);
      
    } catch (error) {
      logger.error('Error in status command:', error);
      await this.sendMessage(from, `‚ùå Error retrieving status: ${error.message}`);
    }
  }

  // Handle reset command for admins
  async handleResetCommand(from, phone) {
    try {
      const beforeStates = this.userStates.size;
      const beforeTransactions = this.pendingTransactions.size;
      
      this.userStates.clear();
      this.pendingTransactions.clear();
      
      const response = `üîÑ *ZAPPO Admin Reset Complete*

‚úÖ *Cleared:*
‚Ä¢ User States: ${beforeStates} ‚Üí 0
‚Ä¢ Pending Transactions: ${beforeTransactions} ‚Üí 0

üïê *Reset at:* ${new Date().toISOString()}`;

      await this.sendMessage(from, response);
      logger.info(`Admin reset executed by ${phone}`);
      
    } catch (error) {
      logger.error('Error in reset command:', error);
      await this.sendMessage(from, `‚ùå Error executing reset: ${error.message}`);
    }
  }

  // Handle mainnet status check for existing users
  async handleMainnetStatus(from, phone) {
    try {
      const currentUser = await users.findUserByPhone(phone);
      const isMainnetUser = await testnetMigration.isMainnetUser(phone);
      
      if (!isMainnetUser) {
        await this.sendMessage(from, `‚ÑπÔ∏è *Testnet User*

You don't have a mainnet wallet with ZAPPO. This testnet wallet is your primary wallet.

üß™ *Current Status:* Testnet Only - Test without real money!

üîó [Get Free Testnet ETH](https://arbitrum.faucet.dev/ArbSepolia)`);
        return;
      }

      const mainnetUserData = await testnetMigration.getMainnetUser(phone);
      
      const statusMessage = `üè¶ *Mainnet Wallet Status*

‚úÖ *Your mainnet wallet is safe and preserved*

üìä *Mainnet Wallet Details:*
‚Ä¢ Address: \`${mainnetUserData?.wallet_address || 'Unknown'}\`
‚Ä¢ Status: Preserved & Secure
‚Ä¢ Network: arbitrum C-Chain (Mainnet)

üß™ *Current Testnet Wallet:*
‚Ä¢ Address: \`${currentUser?.wallet_address || 'Not created'}\`
‚Ä¢ Network: arbitrum Fuji (Testnet)
‚Ä¢ Status: ${currentUser ? 'Active' : 'Not created'}

üîÑ *Migration Info:*
‚Ä¢ Migrated: ${currentUser?.migration_date ? new Date(currentUser.migration_date).toLocaleDateString() : 'N/A'}
‚Ä¢ Your mainnet funds will be restored when ZAPPO returns to mainnet

üí° *For now, enjoy testing on Fuji testnet!*
üîó [Get Free Testnet ETH](https://arbitrum.faucet.dev/ArbSepolia)`;

      await this.sendMessage(from, statusMessage);
      
    } catch (error) {
      logger.error('Error checking mainnet status:', error);
      await this.sendMessage(from, `‚ùå Error checking mainnet status: ${error.message}`);
    }
  }

  async executeUSDCDeposit(from, phone, pendingDeposit) {
    try {
      const { amount, zapTokens } = pendingDeposit;
      
      await this.sendMessage(from, '‚è≥ Processing your USDC deposit...');
      
      // Call the smart contract deposit function
      const result = await deposit(amount);
      
      if (result.success) {
        // Get updated balances
        const zapBalance = await getZAPBalance();
        const formattedZapBalance = (parseFloat(zapBalance) * 1e18).toFixed(0);
        
        // Get current USDC balance
        let currentUSDCBalance = 0;
        try {
          const balances = await checkBalances();
          if (balances && balances.usdc) {
            currentUSDCBalance = parseFloat(balances.usdc);
          }
        } catch (error) {
          logger.warn('Could not fetch updated USDC balance:', error.message);
        }
        
        const successMessage = `‚úÖ *Deposit Successful!* üéâ

üéØ *Transaction Summary:*
‚Ä¢ Deposited: ${amount} USDC
‚Ä¢ ZAP Tokens Earned: ${zapTokens} ZAP
‚Ä¢ Rate Applied: 1:1 conversion

üìä *Updated Balances:*
‚Ä¢ Current USDC: ${currentUSDCBalance.toFixed(4)} USDC
‚Ä¢ Total ZAP Tokens: ${parseInt(formattedZapBalance).toLocaleString()} ZAP

ÔøΩ *Transaction Details:*
‚Ä¢ Hash: ${result.hash}
‚Ä¢ Network: Arbitrum Sepolia
‚Ä¢ Status: Confirmed

üåê *View on Explorer:*
https://sepolia.arbiscan.io/tx/${result.hash}

üéä *Welcome to the ZAP ecosystem!*

*Next Steps:*
‚Ä¢ Type "balance" to check all balances
‚Ä¢ Type "deposit usdc" to deposit more
‚Ä¢ Type "explore defi" for more options`;

        await this.sendMessage(from, successMessage);
        
        logger.info(`USDC deposit successful for ${phone}: ${amount} USDC`);
      } else {
        await this.sendMessage(from, `‚ùå Deposit failed: ${result.error}`);
        logger.error(`USDC deposit failed for ${phone}: ${result.error}`);
      }
      
    } catch (error) {
      logger.error('Error executing USDC deposit:', error);
      await this.sendMessage(from, `‚ùå Deposit failed: ${error.message}`);
    }
  }
}

module.exports = {
  initializeCommandHandler: (whatsapp) => {
    const handler = new CommandHandler(whatsapp);
    handler.initialize();
    return handler;
  }
};
